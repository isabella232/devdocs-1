<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>scipy.sparse.csgraph.min_weight_full_bipartite_matching &mdash; SciPy v1.7.0.dev0+5ac5f63 Reference Guide</title>
    
    <link rel="stylesheet" type="text/css" href="../_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="../_static/css/spc-extend.css">
    <link rel="stylesheet" href="../_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" >
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/scipy-mathjax/MathJax.js?config=scipy-mathjax"></script>
    <script type="text/javascript" src="../_static/js/copybutton.js"></script>
    <link rel="index" title="Index" href="../genindex.html" >
    <link rel="search" title="Search" href="../search.html" >
    <link rel="top" title="SciPy v1.7.0.dev0+5ac5f63 Reference Guide" href="../index.html" >
    <link rel="up" title="Compressed sparse graph routines (scipy.sparse.csgraph)" href="../sparse.csgraph.html" >
    <link rel="next" title="scipy.sparse.csgraph.structural_rank" href="scipy.sparse.csgraph.structural_rank.html" >
    <link rel="prev" title="scipy.sparse.csgraph.maximum_bipartite_matching" href="scipy.sparse.csgraph.maximum_bipartite_matching.html" > 
  </head>
  <body>

<div class="container">
  <div class="top-scipy-org-logo-header">
    <a href="../index.html">
      <img style="border: 0;" alt="SciPy" src="../_static/img/scipy_org_logo.png"></a>
    </div>
  </div>
</div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
        <li class="active"><a href="https://scipy.org/">SciPy.org</a></li>
        <li class="active"><a href="https://docs.scipy.org/">Docs</a></li>
	
        <li class="active"><a href="../index.html">SciPy v1.7.0.dev0+5ac5f63 Reference Guide</a></li>
	
          <li class="active"><a href="../sparse.csgraph.html" accesskey="U">Compressed sparse graph routines (<code class="xref py py-mod docutils literal notranslate"><span class="pre">scipy.sparse.csgraph</span></code>)</a></li> 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="../genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="../py-modindex.html" title="Python Module Index"
           >modules</a>
      </li>
      <li class="active">
        <a href="scipy.sparse.csgraph.structural_rank.html" title="scipy.sparse.csgraph.structural_rank"
           accesskey="N">next</a>
      </li>
      <li class="active">
        <a href="scipy.sparse.csgraph.maximum_bipartite_matching.html" title="scipy.sparse.csgraph.maximum_bipartite_matching"
           accesskey="P">previous</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <div class="section" id="scipy-sparse-csgraph-min-weight-full-bipartite-matching">
<h1>scipy.sparse.csgraph.min_weight_full_bipartite_matching<a class="headerlink" href="#scipy-sparse-csgraph-min-weight-full-bipartite-matching" title="Permalink to this headline">¶</a></h1>
<dl class="py function">
<dt id="scipy.sparse.csgraph.min_weight_full_bipartite_matching">
<code class="sig-prename descclassname"><span class="pre">scipy.sparse.csgraph.</span></code><code class="sig-name descname"><span class="pre">min_weight_full_bipartite_matching</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">biadjacency_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maximize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#scipy.sparse.csgraph.min_weight_full_bipartite_matching" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the minimum weight full matching of a bipartite graph.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.6.0.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>biadjacency_matrix</strong><span class="classifier">sparse matrix</span></dt><dd><p>Biadjacency matrix of the bipartite graph: A sparse matrix in CSR, CSC,
or COO format whose rows represent one partition of the graph and whose
columns represent the other partition. An edge between two vertices is
indicated by the corresponding entry in the matrix, and the weight of
the edge is given by the value of that entry. This should not be
confused with the full adjacency matrix of the graph, as we only need
the submatrix defining the bipartite structure.</p>
</dd>
<dt><strong>maximize</strong><span class="classifier">bool (default: False)</span></dt><dd><p>Calculates a maximum weight matching if true.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>row_ind, col_ind</strong><span class="classifier">array</span></dt><dd><p>An array of row indices and one of corresponding column indices giving
the optimal matching. The total weight of the matching can be computed
as <code class="docutils literal notranslate"><span class="pre">graph[row_ind,</span> <span class="pre">col_ind].sum()</span></code>. The row indices will be
sorted; in the case of a square matrix they will be equal to
<code class="docutils literal notranslate"><span class="pre">numpy.arange(graph.shape[0])</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Let <span class="math notranslate nohighlight">\(G = ((U, V), E)\)</span> be a weighted bipartite graph with non-zero
weights <span class="math notranslate nohighlight">\(w : E \to \mathbb{R} \setminus \{0\}\)</span>. This function then
produces a matching <span class="math notranslate nohighlight">\(M \subseteq E\)</span> with cardinality</p>
<div class="math notranslate nohighlight">
\[\lvert M \rvert = \min(\lvert U \rvert, \lvert V \rvert),\]</div>
<p>which minimizes the sum of the weights of the edges included in the
matching, <span class="math notranslate nohighlight">\(\sum_{e \in M} w(e)\)</span>, or raises an error if no such
matching exists.</p>
<p>When <span class="math notranslate nohighlight">\(\lvert U \rvert = \lvert V \rvert\)</span>, this is commonly
referred to as a perfect matching; here, since we allow
<span class="math notranslate nohighlight">\(\lvert U \rvert\)</span> and <span class="math notranslate nohighlight">\(\lvert V \rvert\)</span> to differ, we
follow Karp <a class="reference internal" href="#r380e4b1f3931-1" id="id1">[1]</a> and refer to the matching as <em>full</em>.</p>
<p>This function implements the LAPJVsp algorithm <a class="reference internal" href="#r380e4b1f3931-2" id="id2">[2]</a>, short for “Linear
assignment problem, Jonker–Volgenant, sparse”.</p>
<p>The problem it solves is equivalent to the rectangular linear assignment
problem. <a class="reference internal" href="#r380e4b1f3931-3" id="id3">[3]</a> As such, this function can be used to solve the same problems
as <a class="reference internal" href="scipy.optimize.linear_sum_assignment.html#scipy.optimize.linear_sum_assignment" title="scipy.optimize.linear_sum_assignment"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.optimize.linear_sum_assignment</span></code></a>. That function may perform
better when the input is dense, or for certain particular types of inputs,
such as those for which the <span class="math notranslate nohighlight">\((i, j)\)</span>’th entry is the distance between
two points in Euclidean space.</p>
<p>If no full matching exists, this function raises a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>. For
determining the size of the largest matching in the graph, see
<a class="reference internal" href="scipy.sparse.csgraph.maximum_bipartite_matching.html#scipy.sparse.csgraph.maximum_bipartite_matching" title="scipy.sparse.csgraph.maximum_bipartite_matching"><code class="xref py py-func docutils literal notranslate"><span class="pre">maximum_bipartite_matching</span></code></a>.</p>
<p>We require that weights are non-zero only to avoid issues with the handling
of explicit zeros when converting between different sparse representations.
Zero weights can be handled by adding a constant to all weights, so that
the resulting matrix contains no zeros.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r380e4b1f3931-1"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Richard Manning Karp:
An algorithm to Solve the m x n Assignment Problem in Expected Time
O(mn log n).
Networks, 10(2):143-152, 1980.</p>
</dd>
<dt class="label" id="r380e4b1f3931-2"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>Roy Jonker and Anton Volgenant:
A Shortest Augmenting Path Algorithm for Dense and Sparse Linear
Assignment Problems.
Computing 38:325-340, 1987.</p>
</dd>
<dt class="label" id="r380e4b1f3931-3"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Assignment_problem">https://en.wikipedia.org/wiki/Assignment_problem</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">csr_matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.sparse.csgraph</span> <span class="kn">import</span> <span class="n">min_weight_full_bipartite_matching</span>
</pre></div>
</div>
<p>Let us first consider an example in which all weights are equal:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">biadjacency_matrix</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
</pre></div>
</div>
<p>Here, all we get is a perfect matching of the graph:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">min_weight_full_bipartite_matching</span><span class="p">(</span><span class="n">biadjacency_matrix</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">[2 0 1]</span>
</pre></div>
</div>
<p>That is, the first, second, and third rows are matched with the third,
first, and second column respectively. Note that in this example, the 0
in the input matrix does <em>not</em> correspond to an edge with weight 0, but
rather a pair of vertices not paired by an edge.</p>
<p>Note also that in this case, the output matches the result of applying
<a class="reference internal" href="scipy.sparse.csgraph.maximum_bipartite_matching.html#scipy.sparse.csgraph.maximum_bipartite_matching" title="scipy.sparse.csgraph.maximum_bipartite_matching"><code class="xref py py-func docutils literal notranslate"><span class="pre">maximum_bipartite_matching</span></code></a>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.sparse.csgraph</span> <span class="kn">import</span> <span class="n">maximum_bipartite_matching</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">biadjacency</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">maximum_bipartite_matching</span><span class="p">(</span><span class="n">biadjacency</span><span class="p">,</span> <span class="n">perm_type</span><span class="o">=</span><span class="s1">&#39;column&#39;</span><span class="p">))</span>
<span class="go">[2 0 1]</span>
</pre></div>
</div>
<p>When multiple edges are available, the ones with lowest weights are
preferred:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">biadjacency</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">row_ind</span><span class="p">,</span> <span class="n">col_ind</span> <span class="o">=</span> <span class="n">min_weight_full_bipartite_matching</span><span class="p">(</span><span class="n">biadjacency</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">col_ind</span><span class="p">)</span>
<span class="go">[0 2 1]</span>
</pre></div>
</div>
<p>The total weight in this case is <span class="math notranslate nohighlight">\(3 + 5 + 1 = 9\)</span>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">biadjacency</span><span class="p">[</span><span class="n">row_ind</span><span class="p">,</span> <span class="n">col_ind</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
<span class="go">9</span>
</pre></div>
</div>
<p>When the matrix is not square, i.e. when the two partitions have different
cardinalities, the matching is as large as the smaller of the two
partitions:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">biadjacency</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">row_ind</span><span class="p">,</span> <span class="n">col_ind</span> <span class="o">=</span> <span class="n">min_weight_full_bipartite_matching</span><span class="p">(</span><span class="n">biadjacency</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">row_ind</span><span class="p">,</span> <span class="n">col_ind</span><span class="p">)</span>
<span class="go">[0 1] [2 1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">biadjacency</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">row_ind</span><span class="p">,</span> <span class="n">col_ind</span> <span class="o">=</span> <span class="n">min_weight_full_bipartite_matching</span><span class="p">(</span><span class="n">biadjacency</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">row_ind</span><span class="p">,</span> <span class="n">col_ind</span><span class="p">)</span>
<span class="go">[0 2] [1 0]</span>
</pre></div>
</div>
<p>When one or both of the partitions are empty, the matching is empty as
well:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">biadjacency</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">row_ind</span><span class="p">,</span> <span class="n">col_ind</span> <span class="o">=</span> <span class="n">min_weight_full_bipartite_matching</span><span class="p">(</span><span class="n">biadjacency</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">row_ind</span><span class="p">,</span> <span class="n">col_ind</span><span class="p">)</span>
<span class="go">[] []</span>
</pre></div>
</div>
<p>In general, we will always reach the same sum of weights as if we had used
<a class="reference internal" href="scipy.optimize.linear_sum_assignment.html#scipy.optimize.linear_sum_assignment" title="scipy.optimize.linear_sum_assignment"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.optimize.linear_sum_assignment</span></code></a> but note that for that one,
missing edges are represented by a matrix entry of <code class="docutils literal notranslate"><span class="pre">float('inf')</span></code>. Let us
generate a random sparse matrix with integer entries between 1 and 10:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">random</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">linear_sum_assignment</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sparse</span> <span class="o">=</span> <span class="n">random</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span> <span class="n">density</span><span class="o">=.</span><span class="mi">5</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;coo&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sparse</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">sparse</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dense</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dense</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">sparse</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dense</span><span class="p">[</span><span class="n">sparse</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">sparse</span><span class="o">.</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sparse</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">row_ind</span><span class="p">,</span> <span class="n">col_ind</span> <span class="o">=</span> <span class="n">linear_sum_assignment</span><span class="p">(</span><span class="n">dense</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">dense</span><span class="p">[</span><span class="n">row_ind</span><span class="p">,</span> <span class="n">col_ind</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
<span class="go">28.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">row_ind</span><span class="p">,</span> <span class="n">col_ind</span> <span class="o">=</span> <span class="n">min_weight_full_bipartite_matching</span><span class="p">(</span><span class="n">sparse</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sparse</span><span class="p">[</span><span class="n">row_ind</span><span class="p">,</span> <span class="n">col_ind</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
<span class="go">28.0</span>
</pre></div>
</div>
</dd></dl>

</div>


          </div>
        </div>
          </div>
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="scipy.sparse.csgraph.maximum_bipartite_matching.html"
                        title="previous chapter">scipy.sparse.csgraph.maximum_bipartite_matching</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="scipy.sparse.csgraph.structural_rank.html"
                        title="next chapter">scipy.sparse.csgraph.structural_rank</a></p>
<div id="searchbox" style="display: none" role="search">
  <h4>Quick search</h4>
    <div>
    <form class="search" action="../search.html" method="get">
      <input type="text" style="width: inherit;" name="q" />
      <input type="submit" value="search" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2008-2021, The SciPy community.
      </li>
      <li>
      Last updated on Feb 20, 2021.
      </li>
      <li>
      Created using <a href="https://www.sphinx-doc.org">Sphinx</a> 3.5.1.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>